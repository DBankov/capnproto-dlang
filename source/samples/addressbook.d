//Generated by Cap'n Proto compiler, DO NOT EDIT.
//source: addressbook.capnp

module addressbook;

import capnproto;

static final class Person
{
public:
	static immutable structSize = cast(immutable)new StructSize(1, 4);
	
	static final class Factory : StructFactory!(Builder, Reader)
	{
	public:
		this()
		{
		}
		Reader constructReader(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
		{
			return new Reader(segment, data, pointers, dataSize, pointerCount, nestingLimit);
		}
		Builder constructBuilder(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
		{
			return new Builder(segment, data, pointers, dataSize, pointerCount);
		}
		immutable(StructSize) structSize()
		{
			return Person.structSize;
		}
		override Reader asReader(Builder builder)
		{
			return builder.asReader();
		}
	}
	static immutable factory = cast(immutable)new Factory();
	static immutable listFactory = cast(immutable)new StructList.Factory!(Builder, Reader)(cast(Factory)factory);
	
	static final class Builder : StructBuilder
	{
	public:
		this(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
		{
			super(segment, data, pointers, dataSize, pointerCount);
		}
		Reader asReader()
		{
			return new Reader(segment, data, pointers, dataSize, pointerCount, 0x7fffffff);
		}
		
		uint getId()
		{
			return _getUintField(0);
		}
		void setId(uint value)
		{
			_setUintField(0, value);
		}
		
		bool hasName()
		{
			return !_pointerFieldIsNull(0);
		}
		Text.Builder getName()
		{
			return _getPointerField!Text(0, null, 0, 0);
		}
		void setName(Text.Reader value)
		{
			_setPointerField!Text(0, value);
		}
		void setName(string value)
		{
			_setPointerField!Text(0, new Text.Reader(value));
		}
		Text.Builder initName(int size)
		{
			return _initPointerField!Text(0, size);
		}
		
		bool hasEmail()
		{
			return !_pointerFieldIsNull(1);
		}
		Text.Builder getEmail()
		{
			return _getPointerField!Text(1, null, 0, 0);
		}
		void setEmail(Text.Reader value)
		{
			_setPointerField!Text(1, value);
		}
		void setEmail(string value)
		{
			_setPointerField!Text(1, new Text.Reader(value));
		}
		Text.Builder initEmail(int size)
		{
			return _initPointerField!Text(1, size);
		}
		
		bool hasPhones()
		{
			return !_pointerFieldIsNull(2);
		}
		StructList.Builder!(.Person.PhoneNumber.Builder) getPhones()
		{
			return _getPointerListField!(.Person.PhoneNumber)(2, null, 0);
		}
		void setPhones(StructList.Reader!(.Person.PhoneNumber.Reader) value)
		{
			_setPointerListField!(.Person.PhoneNumber)(2, value);
		}
		StructList.Builder!(.Person.PhoneNumber.Builder) initPhones(int size)
		{
			return _initPointerListField!(.Person.PhoneNumber)(2, size);
		}
		
		Employment.Builder getEmployment()
		{
			return new Person.Employment.Builder(segment, data, pointers, dataSize, pointerCount);
		}
		Employment.Builder initEmployment()
		{
			_setUshortField(2, cast(ushort)0);
			_clearPointerField(3);
			return new Person.Employment.Builder(segment, data, pointers, dataSize, pointerCount);
		}
		
	}
	
	static final class Reader : StructReader
	{
	public:
		this(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
		{
			super(segment, data, pointers, dataSize, pointerCount, nestingLimit);
		}
		
		uint getId()
		{
			return _getUintField(0);
		}
		
		bool hasName()
		{
			return !_pointerFieldIsNull(0);
		}
		string getName()
		{
			return _getPointerField!Text(0, null, 0, 0).toString();
		}
		
		bool hasEmail()
		{
			return !_pointerFieldIsNull(1);
		}
		string getEmail()
		{
			return _getPointerField!Text(1, null, 0, 0).toString();
		}
		
		bool hasPhones()
		{
			return !_pointerFieldIsNull(2);
		}
		StructList.Reader!(.Person.PhoneNumber.Reader) getPhones()
		{
			return _getPointerListField!(.Person.PhoneNumber)(2, null, 0);
		}
		
		Employment.Reader getEmployment()
		{
			return new Person.Employment.Reader(segment, data, pointers, dataSize, pointerCount, nestingLimit);
		}
		
	}
	
	static final class PhoneNumber
	{
	public:
		static immutable structSize = cast(immutable)new StructSize(1, 1);
		
		static final class Factory : StructFactory!(Builder, Reader)
		{
		public:
			this()
			{
			}
			Reader constructReader(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
			{
				return new Reader(segment, data, pointers, dataSize, pointerCount, nestingLimit);
			}
			Builder constructBuilder(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
			{
				return new Builder(segment, data, pointers, dataSize, pointerCount);
			}
			immutable(StructSize) structSize()
			{
				return Person.PhoneNumber.structSize;
			}
			override Reader asReader(Builder builder)
			{
				return builder.asReader();
			}
		}
		static immutable factory = cast(immutable)new Factory();
		static immutable listFactory = cast(immutable)new StructList.Factory!(Builder, Reader)(cast(Factory)factory);
		
		static final class Builder : StructBuilder
		{
		public:
			this(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
			{
				super(segment, data, pointers, dataSize, pointerCount);
			}
			Reader asReader()
			{
				return new Reader(segment, data, pointers, dataSize, pointerCount, 0x7fffffff);
			}
			
			bool hasNumber()
			{
				return !_pointerFieldIsNull(0);
			}
			Text.Builder getNumber()
			{
				return _getPointerField!Text(0, null, 0, 0);
			}
			void setNumber(Text.Reader value)
			{
				_setPointerField!Text(0, value);
			}
			void setNumber(string value)
			{
				_setPointerField!Text(0, new Text.Reader(value));
			}
			Text.Builder initNumber(int size)
			{
				return _initPointerField!Text(0, size);
			}
			
			.Person.PhoneNumber.Type getType()
			{
				switch(_getUshortField(0))
				{
					case 0: return .Person.PhoneNumber.Type.mobile;
					case 1: return .Person.PhoneNumber.Type.home;
					case 2: return .Person.PhoneNumber.Type.work;
					default: return .Person.PhoneNumber.Type._NOT_IN_SCHEMA;
				}
			}
			void setType(.Person.PhoneNumber.Type value)
			{
				_setShortField(0, cast(ushort)value);
			}
			
		}
		
		static final class Reader : StructReader
		{
		public:
			this(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
			{
				super(segment, data, pointers, dataSize, pointerCount, nestingLimit);
			}
			
			bool hasNumber()
			{
				return !_pointerFieldIsNull(0);
			}
			string getNumber()
			{
				return _getPointerField!Text(0, null, 0, 0).toString();
			}
			
			.Person.PhoneNumber.Type getType()
			{
				switch(_getUshortField(0))
				{
					case 0: return .Person.PhoneNumber.Type.mobile;
					case 1: return .Person.PhoneNumber.Type.home;
					case 2: return .Person.PhoneNumber.Type.work;
					default: return .Person.PhoneNumber.Type._NOT_IN_SCHEMA;
				}
			}
			
		}
		
		enum Type : ushort
		{
			mobile,
			home,
			work,
			_NOT_IN_SCHEMA,
		}
		
	}
	
	static final class Employment
	{
	public:
		static immutable structSize = cast(immutable)new StructSize(1, 4);
		
		static final class Factory : StructFactory!(Builder, Reader)
		{
		public:
			this()
			{
			}
			Reader constructReader(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
			{
				return new Reader(segment, data, pointers, dataSize, pointerCount, nestingLimit);
			}
			Builder constructBuilder(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
			{
				return new Builder(segment, data, pointers, dataSize, pointerCount);
			}
			immutable(StructSize) structSize()
			{
				return Person.Employment.structSize;
			}
			override Reader asReader(Builder builder)
			{
				return builder.asReader();
			}
		}
		static immutable factory = cast(immutable)new Factory();
		static immutable listFactory = cast(immutable)new StructList.Factory!(Builder, Reader)(cast(Factory)factory);
		
		static final class Builder : StructBuilder
		{
		public:
			this(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
			{
				super(segment, data, pointers, dataSize, pointerCount);
			}
			Which which()
			{
				switch(_getUshortField(2))
				{
					case 0: return Which.unemployed;
					case 1: return Which.employer;
					case 2: return Which.school;
					case 3: return Which.selfEmployed;
					default: return Which._NOT_IN_SCHEMA;
				}
			}
			
			Reader asReader()
			{
				return new Reader(segment, data, pointers, dataSize, pointerCount, 0x7fffffff);
			}
			
			bool isUnemployed()
			{
				return which() == Person.Employment.Which.unemployed;
			}
			Void getUnemployed()
			{
				assert(which() == Person.Employment.Which.unemployed, "Must check which() before get()ing a union member.");
				return Void.VOID;
			}
			void setUnemployed(Void value)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.unemployed);
			}
			
			bool isEmployer()
			{
				return which() == Person.Employment.Which.employer;
			}
			bool hasEmployer()
			{
				if(which() != Person.Employment.Which.employer) return false;
				return !_pointerFieldIsNull(3);
			}
			Text.Builder getEmployer()
			{
				return _getPointerField!Text(3, null, 0, 0);
			}
			void setEmployer(Text.Reader value)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.employer);
				_setPointerField!Text(3, value);
			}
			void setEmployer(string value)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.employer);
				_setPointerField!Text(3, new Text.Reader(value));
			}
			Text.Builder initEmployer(int size)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.employer);
				return _initPointerField!Text(3, size);
			}
			
			bool isSchool()
			{
				return which() == Person.Employment.Which.school;
			}
			bool hasSchool()
			{
				if(which() != Person.Employment.Which.school) return false;
				return !_pointerFieldIsNull(3);
			}
			Text.Builder getSchool()
			{
				return _getPointerField!Text(3, null, 0, 0);
			}
			void setSchool(Text.Reader value)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.school);
				_setPointerField!Text(3, value);
			}
			void setSchool(string value)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.school);
				_setPointerField!Text(3, new Text.Reader(value));
			}
			Text.Builder initSchool(int size)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.school);
				return _initPointerField!Text(3, size);
			}
			
			bool isSelfEmployed()
			{
				return which() == Person.Employment.Which.selfEmployed;
			}
			Void getSelfEmployed()
			{
				assert(which() == Person.Employment.Which.selfEmployed, "Must check which() before get()ing a union member.");
				return Void.VOID;
			}
			void setSelfEmployed(Void value)
			{
				_setShortField(2, cast(ushort)Person.Employment.Which.selfEmployed);
			}
			
		}
		
		static final class Reader : StructReader
		{
		public:
			this(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
			{
				super(segment, data, pointers, dataSize, pointerCount, nestingLimit);
			}
			
			Which which()
			{
				switch(_getUshortField(2))
				{
					case 0: return Which.unemployed;
					case 1: return Which.employer;
					case 2: return Which.school;
					case 3: return Which.selfEmployed;
					default: return Which._NOT_IN_SCHEMA;
				}
			}
			
			bool isUnemployed()
			{
				return which() == Person.Employment.Which.unemployed;
			}
			Void getUnemployed()
			{
				assert(which() == Person.Employment.Which.unemployed, "Must check which() before get()ing a union member.");
				return Void.VOID;
			}
			
			bool isEmployer()
			{
				return which() == Person.Employment.Which.employer;
			}
			bool hasEmployer()
			{
				if(which() != Person.Employment.Which.employer) return false;
				return !_pointerFieldIsNull(3);
			}
			string getEmployer()
			{
				return _getPointerField!Text(3, null, 0, 0).toString();
			}
			
			bool isSchool()
			{
				return which() == Person.Employment.Which.school;
			}
			bool hasSchool()
			{
				if(which() != Person.Employment.Which.school) return false;
				return !_pointerFieldIsNull(3);
			}
			string getSchool()
			{
				return _getPointerField!Text(3, null, 0, 0).toString();
			}
			
			bool isSelfEmployed()
			{
				return which() == Person.Employment.Which.selfEmployed;
			}
			Void getSelfEmployed()
			{
				assert(which() == Person.Employment.Which.selfEmployed, "Must check which() before get()ing a union member.");
				return Void.VOID;
			}
			
		}
		
		enum Which : ushort
		{
			unemployed,
			employer,
			school,
			selfEmployed,
			_NOT_IN_SCHEMA,
		}
	}
	
}

static final class AddressBook
{
public:
	static immutable structSize = cast(immutable)new StructSize(0, 1);
	
	static final class Factory : StructFactory!(Builder, Reader)
	{
	public:
		this()
		{
		}
		Reader constructReader(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
		{
			return new Reader(segment, data, pointers, dataSize, pointerCount, nestingLimit);
		}
		Builder constructBuilder(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
		{
			return new Builder(segment, data, pointers, dataSize, pointerCount);
		}
		immutable(StructSize) structSize()
		{
			return AddressBook.structSize;
		}
		override Reader asReader(Builder builder)
		{
			return builder.asReader();
		}
	}
	static immutable factory = cast(immutable)new Factory();
	static immutable listFactory = cast(immutable)new StructList.Factory!(Builder, Reader)(cast(Factory)factory);
	
	static final class Builder : StructBuilder
	{
	public:
		this(SegmentBuilder segment, int data, int pointers, int dataSize, short pointerCount)
		{
			super(segment, data, pointers, dataSize, pointerCount);
		}
		Reader asReader()
		{
			return new Reader(segment, data, pointers, dataSize, pointerCount, 0x7fffffff);
		}
		
		bool hasPeople()
		{
			return !_pointerFieldIsNull(0);
		}
		StructList.Builder!(.Person.Builder) getPeople()
		{
			return _getPointerListField!(.Person)(0, null, 0);
		}
		void setPeople(StructList.Reader!(.Person.Reader) value)
		{
			_setPointerListField!(.Person)(0, value);
		}
		StructList.Builder!(.Person.Builder) initPeople(int size)
		{
			return _initPointerListField!(.Person)(0, size);
		}
		
	}
	
	static final class Reader : StructReader
	{
	public:
		this(SegmentReader segment, int data, int pointers, int dataSize, short pointerCount, int nestingLimit)
		{
			super(segment, data, pointers, dataSize, pointerCount, nestingLimit);
		}
		
		bool hasPeople()
		{
			return !_pointerFieldIsNull(0);
		}
		StructList.Reader!(.Person.Reader) getPeople()
		{
			return _getPointerListField!(.Person)(0, null, 0);
		}
		
	}
	
}

final class Schemas
{
public:
	__gshared static SegmentReader b_98808e9832e8bc18 = GeneratedClassSupport.decodeRawBytes(
	  "\u0000\u0000\u0000\u0000\u0005\u0000\u0006\u0000" ~
	  "\u0018\u00bc\u00e8\u0032\u0098\u008e\u0080\u0098" ~
	  "\u0012\u0000\u0000\u0000\u0001\u0000\u0001\u0000" ~
	  "\u0074\u00e1\u006e\u00f8\u0019\u002e\u00b3\u009e" ~
	  "\u0004\u0000\u0007\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0015\u0000\u0000\u0000\u00ca\u0000\u0000\u0000" ~
	  "\u0021\u0000\u0000\u0000\u0017\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u002d\u0000\u0000\u0000\u001f\u0001\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0061\u0064\u0064\u0072\u0065\u0073\u0073\u0062" ~
	  "\u006f\u006f\u006b\u002e\u0063\u0061\u0070\u006e" ~
	  "\u0070\u003a\u0050\u0065\u0072\u0073\u006f\u006e" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0004\u0000\u0000\u0000\u0001\u0000\u0001\u0000" ~
	  "\u00d0\u008a\u009e\u009c\u00b2\u0090\u004e\u0081" ~
	  "\u0001\u0000\u0000\u0000\u0062\u0000\u0000\u0000" ~
	  "\u0050\u0068\u006f\u006e\u0065\u004e\u0075\u006d" ~
	  "\u0062\u0065\u0072\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0014\u0000\u0000\u0000\u0003\u0000\u0004\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u007d\u0000\u0000\u0000\u001a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0078\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0084\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0001\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0081\u0000\u0000\u0000\u002a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u007c\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0088\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0002\u0000\u0000\u0000\u0001\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0002\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0085\u0000\u0000\u0000\u0032\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0080\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u008c\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0003\u0000\u0000\u0000\u0002\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0003\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0089\u0000\u0000\u0000\u003a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0084\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u00a0\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u003d\u0069\u00c3\u00bd\u00d4\u002b\u000b\u00bb" ~
	  "\u009d\u0000\u0000\u0000\u005a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0069\u0064\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0008\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0008\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u006e\u0061\u006d\u0065\u0000\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0065\u006d\u0061\u0069\u006c\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0070\u0068\u006f\u006e\u0065\u0073\u0000\u0000" ~
	  "\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0010\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u00d0\u008a\u009e\u009c\u00b2\u0090\u004e\u0081" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0065\u006d\u0070\u006c\u006f\u0079\u006d\u0065" ~
	  "\u006e\u0074\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "");
	__gshared static SegmentReader b_814e90b29c9e8ad0 = GeneratedClassSupport.decodeRawBytes(
	  "\u0000\u0000\u0000\u0000\u0005\u0000\u0006\u0000" ~
	  "\u00d0\u008a\u009e\u009c\u00b2\u0090\u004e\u0081" ~
	  "\u0019\u0000\u0000\u0000\u0001\u0000\u0001\u0000" ~
	  "\u0018\u00bc\u00e8\u0032\u0098\u008e\u0080\u0098" ~
	  "\u0001\u0000\u0007\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0015\u0000\u0000\u0000\u002a\u0001\u0000\u0000" ~
	  "\u0025\u0000\u0000\u0000\u0017\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u002d\u0000\u0000\u0000\u0077\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0061\u0064\u0064\u0072\u0065\u0073\u0073\u0062" ~
	  "\u006f\u006f\u006b\u002e\u0063\u0061\u0070\u006e" ~
	  "\u0070\u003a\u0050\u0065\u0072\u0073\u006f\u006e" ~
	  "\u002e\u0050\u0068\u006f\u006e\u0065\u004e\u0075" ~
	  "\u006d\u0062\u0065\u0072\u0000\u0000\u0000\u0000" ~
	  "\u0004\u0000\u0000\u0000\u0001\u0000\u0001\u0000" ~
	  "\u002f\u0006\u0085\u00d5\u0004\u00bd\u00e0\u0091" ~
	  "\u0001\u0000\u0000\u0000\u002a\u0000\u0000\u0000" ~
	  "\u0054\u0079\u0070\u0065\u0000\u0000\u0000\u0000" ~
	  "\u0008\u0000\u0000\u0000\u0003\u0000\u0004\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0029\u0000\u0000\u0000\u003a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0024\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0030\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0001\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u002d\u0000\u0000\u0000\u002a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0028\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0034\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u006e\u0075\u006d\u0062\u0065\u0072\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0074\u0079\u0070\u0065\u0000\u0000\u0000\u0000" ~
	  "\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u002f\u0006\u0085\u00d5\u0004\u00bd\u00e0\u0091" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "");
	__gshared static SegmentReader b_91e0bd04d585062f = GeneratedClassSupport.decodeRawBytes(
	  "\u0000\u0000\u0000\u0000\u0005\u0000\u0006\u0000" ~
	  "\u002f\u0006\u0085\u00d5\u0004\u00bd\u00e0\u0091" ~
	  "\u0025\u0000\u0000\u0000\u0002\u0000\u0000\u0000" ~
	  "\u00d0\u008a\u009e\u009c\u00b2\u0090\u004e\u0081" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0015\u0000\u0000\u0000\u0052\u0001\u0000\u0000" ~
	  "\u0029\u0000\u0000\u0000\u0007\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0025\u0000\u0000\u0000\u004f\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0061\u0064\u0064\u0072\u0065\u0073\u0073\u0062" ~
	  "\u006f\u006f\u006b\u002e\u0063\u0061\u0070\u006e" ~
	  "\u0070\u003a\u0050\u0065\u0072\u0073\u006f\u006e" ~
	  "\u002e\u0050\u0068\u006f\u006e\u0065\u004e\u0075" ~
	  "\u006d\u0062\u0065\u0072\u002e\u0054\u0079\u0070" ~
	  "\u0065\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0001\u0000\u0001\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0001\u0000\u0002\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u001d\u0000\u0000\u0000\u003a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0015\u0000\u0000\u0000\u002a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\r\u0000\u0000\u0000\u002a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u006d\u006f\u0062\u0069\u006c\u0065\u0000\u0000" ~
	  "\u0068\u006f\u006d\u0065\u0000\u0000\u0000\u0000" ~
	  "\u0077\u006f\u0072\u006b\u0000\u0000\u0000\u0000" ~
	  "");
	__gshared static SegmentReader b_bb0b2bd4bdc3693d = GeneratedClassSupport.decodeRawBytes(
	  "\u0000\u0000\u0000\u0000\u0005\u0000\u0006\u0000" ~
	  "\u003d\u0069\u00c3\u00bd\u00d4\u002b\u000b\u00bb" ~
	  "\u0019\u0000\u0000\u0000\u0001\u0000\u0001\u0000" ~
	  "\u0018\u00bc\u00e8\u0032\u0098\u008e\u0080\u0098" ~
	  "\u0004\u0000\u0007\u0000\u0001\u0000\u0004\u0000" ~
	  "\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0015\u0000\u0000\u0000\"\u0001\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u001d\u0000\u0000\u0000\u00e7\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0061\u0064\u0064\u0072\u0065\u0073\u0073\u0062" ~
	  "\u006f\u006f\u006b\u002e\u0063\u0061\u0070\u006e" ~
	  "\u0070\u003a\u0050\u0065\u0072\u0073\u006f\u006e" ~
	  "\u002e\u0065\u006d\u0070\u006c\u006f\u0079\u006d" ~
	  "\u0065\u006e\u0074\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0010\u0000\u0000\u0000\u0003\u0000\u0004\u0000" ~
	  "\u0000\u0000\u00ff\u00ff\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0004\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0061\u0000\u0000\u0000\u005a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0060\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u006c\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0001\u0000\u00fe\u00ff\u0003\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0005\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0069\u0000\u0000\u0000\u004a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0068\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0074\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0002\u0000\u00fd\u00ff\u0003\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0006\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0071\u0000\u0000\u0000\u003a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u006c\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0078\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0003\u0000\u00fc\u00ff\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0007\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0075\u0000\u0000\u0000\u006a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0074\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0080\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0075\u006e\u0065\u006d\u0070\u006c\u006f\u0079" ~
	  "\u0065\u0064\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0065\u006d\u0070\u006c\u006f\u0079\u0065\u0072" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0073\u0063\u0068\u006f\u006f\u006c\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000c\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0073\u0065\u006c\u0066\u0045\u006d\u0070\u006c" ~
	  "\u006f\u0079\u0065\u0064\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "");
	__gshared static SegmentReader b_f934d9b354a8a134 = GeneratedClassSupport.decodeRawBytes(
	  "\u0000\u0000\u0000\u0000\u0005\u0000\u0006\u0000" ~
	  "\u0034\u00a1\u00a8\u0054\u00b3\u00d9\u0034\u00f9" ~
	  "\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000" ~
	  "\u0074\u00e1\u006e\u00f8\u0019\u002e\u00b3\u009e" ~
	  "\u0001\u0000\u0007\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0015\u0000\u0000\u0000\u00f2\u0000\u0000\u0000" ~
	  "\u0021\u0000\u0000\u0000\u0007\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u001d\u0000\u0000\u0000\u003f\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0061\u0064\u0064\u0072\u0065\u0073\u0073\u0062" ~
	  "\u006f\u006f\u006b\u002e\u0063\u0061\u0070\u006e" ~
	  "\u0070\u003a\u0041\u0064\u0064\u0072\u0065\u0073" ~
	  "\u0073\u0042\u006f\u006f\u006b\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0001\u0000\u0001\u0000" ~
	  "\u0004\u0000\u0000\u0000\u0003\u0000\u0004\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\r\u0000\u0000\u0000\u003a\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0008\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0024\u0000\u0000\u0000\u0002\u0000\u0001\u0000" ~
	  "\u0070\u0065\u006f\u0070\u006c\u0065\u0000\u0000" ~
	  "\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0003\u0000\u0001\u0000" ~
	  "\u0010\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0018\u00bc\u00e8\u0032\u0098\u008e\u0080\u0098" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000" ~
	  "");
}

